"use strict";exports.id=5978,exports.ids=[5978],exports.modules={5978:(t,i,e)=>{e.d(i,{Particle:()=>u});var s=e(9567),o=e(5236),a=e(7385),h=e(827),r=e(4074),l=e(8698),n=e(6513),c=e(107),p=e(6696);let d=0;function f(t){if(!(0,o.dB)(t.outMode,t.checkModes))return;let i=2*t.radius;t.coord>t.maxCoord-i?t.setCb(-t.radius):t.coord<i&&t.setCb(t.radius)}class u{constructor(t,i){this.container=i,this._calcPosition=(t,i,e,o=d)=>{for(let[,s]of t.plugins){let t=void 0!==s.particlePosition?s.particlePosition(i,this):void 0;if(t)return n.U.create(t.x,t.y,e)}let a=t.canvas.size,h=(0,s.mC)({size:a,position:i}),r=n.U.create(h.x,h.y,e),l=this.getRadius(),c=this.options.move.outModes,p=i=>{f({outMode:i,checkModes:["bounce"],coord:r.x,maxCoord:t.canvas.size.width,setCb:t=>r.x+=t,radius:l})},u=i=>{f({outMode:i,checkModes:["bounce"],coord:r.y,maxCoord:t.canvas.size.height,setCb:t=>r.y+=t,radius:l})};return(p(c.left??c.default),p(c.right??c.default),u(c.top??c.default),u(c.bottom??c.default),this._checkOverlap(r,o))?this._calcPosition(t,void 0,e,o+1):r},this._calculateVelocity=()=>{let t=(0,s.lQ)(this.direction).copy(),i=this.options.move;if("inside"===i.direction||"outside"===i.direction)return t;let e=(0,s.Id)((0,s.Gu)(i.angle.value)),o=(0,s.Id)((0,s.Gu)(i.angle.offset)),a={left:o-.5*e,right:o+.5*e};return i.straight||(t.angle+=(0,s.vd)((0,s.Cs)(a.left,a.right))),i.random&&"number"==typeof i.speed&&(t.length*=(0,s.sZ)()),t},this._checkOverlap=(t,i=d)=>{let e=this.options.collisions,o=this.getRadius();if(!e.enable)return!1;let h=e.overlap;if(h.enable)return!1;let r=h.retries;if(r>=0&&i>r)throw Error(`${a.gK} particle is overlapping and can't be placed`);return!!this.container.particles.find(i=>(0,s.Sp)(t,i.position)<o+i.getRadius())},this._getRollColor=t=>{if(!t||!this.roll||!this.backColor&&!this.roll.alter)return t;let i=this.roll.horizontal&&this.roll.vertical?2:1,e=this.roll.horizontal?.5*Math.PI:0;return Math.floor(((this.roll.angle??0)+e)/(Math.PI/i))%2?this.backColor?this.backColor:this.roll.alter?(0,c.PL)(t,this.roll.alter.type,this.roll.alter.value):t:t},this._initPosition=t=>{let i=this.container,e=(0,s.Gu)(this.options.zIndex.value);this.position=this._calcPosition(i,t,(0,s.uZ)(e,0,i.zLayers)),this.initialPosition=this.position.copy();let a=i.canvas.size;switch(this.moveCenter={...(0,o.bt)(this.options.move.center,a),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=(0,s.Gk)(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside"}this.offset=l.O.origin},this._engine=t}destroy(t){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;let i=this.container,e=this.pathGenerator,s=i.shapeDrawers.get(this.shape);for(let[,e]of(s?.particleDestroy?.(this),i.plugins))e.particleDestroyed?.(this,t);for(let e of i.particles.updaters)e.particleDestroyed?.(this,t);e?.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}async draw(t){let i=this.container,e=i.canvas;for(let[,s]of i.plugins)await e.drawParticlePlugin(s,this,t);await e.drawParticle(this,t)}getFillColor(){return this._getRollColor(this.bubble.color??(0,h.gW)(this.color))}getMass(){return this.getRadius()**2*Math.PI*.5}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??(0,h.gW)(this.strokeColor))}async init(t,i,e,l){let n=this.container,c=this._engine;this.id=t,this.group=l,this.effectClose=!0,this.effectFill=!0,this.shapeClose=!0,this.shapeFill=!0,this.pathRotation=!1,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;let d=n.retina.pixelRatio,f=n.actualOptions,u=(0,p.x)(this._engine,n,f.particles),g=u.effect.type,y=u.shape.type,{reduceDuplicates:v}=u;this.effect=(0,o.wA)(g,this.id,v),this.shape=(0,o.wA)(y,this.id,v);let b=u.effect,w=u.shape;if(e){if(e.effect?.type){let t=e.effect.type,i=(0,o.wA)(t,this.id,v);i&&(this.effect=i,b.load(e.effect))}if(e.shape?.type){let t=e.shape.type,i=(0,o.wA)(t,this.id,v);i&&(this.shape=i,w.load(e.shape))}}this.effectData=function(t,i,e,s){let a=i.options[t];if(a)return(0,o.ZB)({close:i.close,fill:i.fill},(0,o.wA)(a,e,s))}(this.effect,b,this.id,v),this.shapeData=function(t,i,e,s){let a=i.options[t];if(a)return(0,o.ZB)({close:i.close,fill:i.fill},(0,o.wA)(a,e,s))}(this.shape,w,this.id,v),u.load(e);let C=this.effectData;C&&u.load(C.particles);let m=this.shapeData;m&&u.load(m.particles);let x=new r.o(c,n);x.load(n.actualOptions.interactivity),x.load(u.interactivity),this.interactivity=x,this.effectFill=C?.fill??u.effect.fill,this.effectClose=C?.close??u.effect.close,this.shapeFill=m?.fill??u.shape.fill,this.shapeClose=m?.close??u.shape.close,this.options=u;let P=this.options.move.path;this.pathDelay=(0,s.Gu)(P.delay.value)*a.X5,P.generator&&(this.pathGenerator=this._engine.getPathGenerator(P.generator),this.pathGenerator&&n.addPath(P.generator,this.pathGenerator)&&await this.pathGenerator.init(n)),n.retina.initParticle(this),this.size=(0,o.V0)(this.options.size,d),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(i),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy(),this.moveDecay=1-(0,s.Gu)(this.options.move.decay);let z=n.particles;z.setLastZIndex(this.position.z),this.zIndexFactor=this.position.z/n.zLayers,this.sides=24;let _=n.effectDrawers.get(this.effect);!_&&(_=this._engine.getEffectDrawer(this.effect))&&n.effectDrawers.set(this.effect,_),_?.loadEffect&&await _.loadEffect(this);let D=n.shapeDrawers.get(this.shape);!D&&(D=this._engine.getShapeDrawer(this.shape))&&n.shapeDrawers.set(this.shape,D),D?.loadShape&&await D.loadShape(this);let R=D?.getSidesCount;for(let t of(R&&(this.sides=R(this)),this.spawning=!1,this.shadowColor=(0,h.tX)(this.options.shadow.color),z.updaters))await t.init(this);for(let t of z.movers)await t.init?.(this);for(let[,t]of(await _?.particleInit?.(n,this),await D?.particleInit?.(n,this),n.plugins))t.particleCreated?.(this)}isInsideCanvas(){let t=this.getRadius(),i=this.container.canvas.size,e=this.position;return e.x>=-t&&e.y>=-t&&e.y<=i.height+t&&e.x<=i.width+t}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(let t of this.container.particles.updaters)t.reset?.(this)}}}};